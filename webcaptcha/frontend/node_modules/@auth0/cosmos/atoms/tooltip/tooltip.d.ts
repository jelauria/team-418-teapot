import * as React from "react";
import { RefHandler } from "react-popper";
export declare type TooltipPosition = "top" | "bottom" | "left" | "right";
export interface ITooltipProps {
    id?: string;
    content: string;
    position?: TooltipPosition;
    defaultVisible?: boolean;
    onClick?: Function;
}
interface ITooltipState {
    visible: boolean;
    id: string;
}
interface IObservedElementProps {
    scheduleUpdate: Function;
    innerRef: RefHandler;
    style: Object;
    "data-placement": string;
    id: string;
}
declare class Tooltip extends React.Component<ITooltipProps, ITooltipState> {
    static ObservedElement: {
        new (props: Readonly<IObservedElementProps>): {
            componentDidUpdate(): void;
            render(): JSX.Element;
            context: any;
            setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<IObservedElementProps>) => {} | Pick<{}, K>) | Pick<{}, K>, callback?: () => void): void;
            forceUpdate(callBack?: () => void): void;
            readonly props: Readonly<IObservedElementProps> & Readonly<{
                children?: React.ReactNode;
            }>;
            state: Readonly<{}>;
            refs: {
                [key: string]: React.ReactInstance;
            };
            componentDidMount?(): void;
            shouldComponentUpdate?(nextProps: Readonly<IObservedElementProps>, nextState: Readonly<{}>, nextContext: any): boolean;
            componentWillUnmount?(): void;
            componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
            getSnapshotBeforeUpdate?(prevProps: Readonly<IObservedElementProps>, prevState: Readonly<{}>): any;
            componentWillMount?(): void;
            UNSAFE_componentWillMount?(): void;
            componentWillReceiveProps?(nextProps: Readonly<IObservedElementProps>, nextContext: any): void;
            UNSAFE_componentWillReceiveProps?(nextProps: Readonly<IObservedElementProps>, nextContext: any): void;
            componentWillUpdate?(nextProps: Readonly<IObservedElementProps>, nextState: Readonly<{}>, nextContext: any): void;
            UNSAFE_componentWillUpdate?(nextProps: Readonly<IObservedElementProps>, nextState: Readonly<{}>, nextContext: any): void;
        };
        new (props: IObservedElementProps, context?: any): {
            componentDidUpdate(): void;
            render(): JSX.Element;
            context: any;
            setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<IObservedElementProps>) => {} | Pick<{}, K>) | Pick<{}, K>, callback?: () => void): void;
            forceUpdate(callBack?: () => void): void;
            readonly props: Readonly<IObservedElementProps> & Readonly<{
                children?: React.ReactNode;
            }>;
            state: Readonly<{}>;
            refs: {
                [key: string]: React.ReactInstance;
            };
            componentDidMount?(): void;
            shouldComponentUpdate?(nextProps: Readonly<IObservedElementProps>, nextState: Readonly<{}>, nextContext: any): boolean;
            componentWillUnmount?(): void;
            componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
            getSnapshotBeforeUpdate?(prevProps: Readonly<IObservedElementProps>, prevState: Readonly<{}>): any;
            componentWillMount?(): void;
            UNSAFE_componentWillMount?(): void;
            componentWillReceiveProps?(nextProps: Readonly<IObservedElementProps>, nextContext: any): void;
            UNSAFE_componentWillReceiveProps?(nextProps: Readonly<IObservedElementProps>, nextContext: any): void;
            componentWillUpdate?(nextProps: Readonly<IObservedElementProps>, nextState: Readonly<{}>, nextContext: any): void;
            UNSAFE_componentWillUpdate?(nextProps: Readonly<IObservedElementProps>, nextState: Readonly<{}>, nextContext: any): void;
        };
        contextType?: React.Context<any>;
    };
    static Action: any | undefined;
    static Element: any;
    static Trigger: any;
    static Arrow: any;
    static defaultProps: {
        content: any;
        position: string;
        defaultVisible: boolean;
    };
    constructor(props: any);
    showTooltip: () => void;
    hideTooltip: () => void;
    onKeyDown: (event: any) => void;
    render(): JSX.Element;
}
export default Tooltip;
